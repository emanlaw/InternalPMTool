{% extends "base.html" %}

{% block title %}Mind Map - Project Planning{% endblock %}

{% block head %}
<link rel="stylesheet" href="/static/css/mindmap.css">
{% endblock %}

{% block content %}
<div class="mindmap-header">
    <h1>ðŸ§  Interactive Mind Map</h1>
    <div class="mindmap-controls">
        <select id="projectSelect" class="form-select">
            <option value="">Select Project</option>
            {% for project in projects %}
            <option value="{{ project.id }}">{{ project.name }}</option>
            {% endfor %}
        </select>
        <button class="btn" onclick="createNode()">+ Add Node</button>
        <button class="btn btn-secondary" onclick="clearCanvas()">Clear</button>
        <button class="btn btn-secondary" onclick="exportMindMap()">Export PNG</button>
        <button class="btn btn-secondary" onclick="exportToJSON()">Export JSON</button>
        <button class="btn btn-secondary" onclick="importFromJSON()">Import JSON</button>
        <button class="btn btn-secondary" onclick="saveMindMap()">Save</button>
        <button class="btn btn-secondary" onclick="showMindMapSummary()">Summary</button>
    </div>
</div>

<div class="mindmap-container">
    <div class="mindmap-toolbar">
        <div class="tool-group">
            <label>Node Type:</label>
            <select id="nodeType">
                <option value="todo">TODO</option>
                <option value="in_progress">In Progress</option>
                <option value="done">Done</option>
                <option value="idea">Idea</option>
            </select>
        </div>
        <div class="tool-group">
            <label>Zoom:</label>
            <button onclick="zoomIn()">+</button>
            <button onclick="zoomOut()">-</button>
            <button onclick="resetZoom()">Reset</button>
        </div>
    </div>
    
    <canvas id="mindmapCanvas" width="1200" height="800"></canvas>
</div>

<style>
.mindmap-header {
    background: white;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.mindmap-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.form-select {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
}

.mindmap-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    overflow: hidden;
}

.mindmap-toolbar {
    background: #f8f9fa;
    padding: 15px;
    border-bottom: 1px solid #ddd;
    display: flex;
    gap: 20px;
    align-items: center;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.tool-group label {
    font-weight: 500;
    color: #5e6c84;
}

.tool-group select, .tool-group button {
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    cursor: pointer;
}

#mindmapCanvas {
    display: block;
    cursor: crosshair;
    background: #fafbfc;
}

/* Dark mode styles */
.dark-mode .mindmap-header,
.dark-mode .mindmap-container {
    background: #2d3748;
    color: #f5f5f5;
}

.dark-mode .mindmap-toolbar {
    background: #374151;
    border-color: #555555;
}

.dark-mode .form-select,
.dark-mode .tool-group select,
.dark-mode .tool-group button {
    background: #374151;
    color: #f0f0f0;
    border-color: #555555;
}

.dark-mode #mindmapCanvas {
    background: #1a1a1a;
}
</style>

<script>
class MindMap {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.nodes = [];
        this.connections = [];
        this.selectedNode = null;
        this.dragging = false;
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.nodeIdCounter = 1;
        
        this.setupEventListeners();
        this.draw();
    }
    
    setupEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));
        this.canvas.addEventListener('contextmenu', (e) => this.onRightClick(e));
    }
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left - this.panX) / this.zoom,
            y: (e.clientY - rect.top - this.panY) / this.zoom
        };
    }
    
    onMouseDown(e) {
        const pos = this.getMousePos(e);
        const node = this.getNodeAt(pos.x, pos.y);
        
        if (node) {
            this.selectedNode = node;
            this.dragging = true;
            this.dragOffset = {
                x: pos.x - node.x,
                y: pos.y - node.y
            };
        } else {
            this.selectedNode = null;
        }
        
        this.draw();
    }
    
    onMouseMove(e) {
        if (this.dragging && this.selectedNode) {
            const pos = this.getMousePos(e);
            this.selectedNode.x = pos.x - this.dragOffset.x;
            this.selectedNode.y = pos.y - this.dragOffset.y;
            this.draw();
        }
    }
    
    onMouseUp(e) {
        this.dragging = false;
    }
    
    onDoubleClick(e) {
        const pos = this.getMousePos(e);
        const node = this.getNodeAt(pos.x, pos.y);
        
        if (node) {
            this.editNode(node);
        } else {
            this.createNodeAt(pos.x, pos.y);
        }
    }
    
    onRightClick(e) {
        e.preventDefault();
        const pos = this.getMousePos(e);
        const node = this.getNodeAt(pos.x, pos.y);
        
        if (node) {
            this.showContextMenu(e, node);
        }
    }
    
    createNodeAt(x, y) {
        const nodeType = document.getElementById('nodeType').value;
        const text = prompt('Enter node text:');
        
        if (text) {
            const node = {
                id: this.nodeIdCounter++,
                x: x,
                y: y,
                text: text,
                type: nodeType,
                width: 120,
                height: 60
            };
            
            this.nodes.push(node);
            this.draw();
        }
    }
    
    editNode(node) {
        const newText = prompt('Edit node text:', node.text);
        if (newText !== null) {
            node.text = newText;
            this.draw();
        }
    }
    
    getNodeAt(x, y) {
        for (let i = this.nodes.length - 1; i >= 0; i--) {
            const node = this.nodes[i];
            if (x >= node.x - node.width/2 && x <= node.x + node.width/2 &&
                y >= node.y - node.height/2 && y <= node.y + node.height/2) {
                return node;
            }
        }
        return null;
    }
    
    getNodeColor(type) {
        const colors = {
            'todo': '#e3fcef',
            'in_progress': '#fff4e6',
            'done': '#e3f2fd',
            'idea': '#f3e5f5'
        };
        return colors[type] || '#f8f9fa';
    }
    
    getNodeBorderColor(type) {
        const colors = {
            'todo': '#36b37e',
            'in_progress': '#ffab00',
            'done': '#0079bf',
            'idea': '#9c27b0'
        };
        return colors[type] || '#ddd';
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        this.ctx.translate(this.panX, this.panY);
        this.ctx.scale(this.zoom, this.zoom);
        
        // Draw connections
        this.connections.forEach(conn => {
            const fromNode = this.nodes.find(n => n.id === conn.from);
            const toNode = this.nodes.find(n => n.id === conn.to);
            
            if (fromNode && toNode) {
                this.drawConnection(fromNode, toNode);
            }
        });
        
        // Draw nodes
        this.nodes.forEach(node => {
            this.drawNode(node);
        });
        
        this.ctx.restore();
    }
    
    drawNode(node) {
        const isSelected = node === this.selectedNode;
        
        // Draw node background
        this.ctx.fillStyle = this.getNodeColor(node.type);
        this.ctx.strokeStyle = isSelected ? '#ff5630' : this.getNodeBorderColor(node.type);
        this.ctx.lineWidth = isSelected ? 3 : 2;
        
        this.ctx.fillRect(
            node.x - node.width/2,
            node.y - node.height/2,
            node.width,
            node.height
        );
        
        this.ctx.strokeRect(
            node.x - node.width/2,
            node.y - node.height/2,
            node.width,
            node.height
        );
        
        // Draw text
        this.ctx.fillStyle = '#172b4d';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // Wrap text
        const words = node.text.split(' ');
        const lines = [];
        let currentLine = '';
        
        words.forEach(word => {
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            const metrics = this.ctx.measureText(testLine);
            
            if (metrics.width > node.width - 10) {
                if (currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    lines.push(word);
                }
            } else {
                currentLine = testLine;
            }
        });
        
        if (currentLine) {
            lines.push(currentLine);
        }
        
        const lineHeight = 16;
        const startY = node.y - (lines.length - 1) * lineHeight / 2;
        
        lines.forEach((line, index) => {
            this.ctx.fillText(line, node.x, startY + index * lineHeight);
        });
    }
    
    drawConnection(fromNode, toNode) {
        this.ctx.strokeStyle = '#5e6c84';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(fromNode.x, fromNode.y);
        this.ctx.lineTo(toNode.x, toNode.y);
        this.ctx.stroke();
        
        // Draw arrow
        const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
        const arrowLength = 10;
        
        this.ctx.beginPath();
        this.ctx.moveTo(toNode.x, toNode.y);
        this.ctx.lineTo(
            toNode.x - arrowLength * Math.cos(angle - Math.PI/6),
            toNode.y - arrowLength * Math.sin(angle - Math.PI/6)
        );
        this.ctx.moveTo(toNode.x, toNode.y);
        this.ctx.lineTo(
            toNode.x - arrowLength * Math.cos(angle + Math.PI/6),
            toNode.y - arrowLength * Math.sin(angle + Math.PI/6)
        );
        this.ctx.stroke();
    }
    
    showContextMenu(e, node) {
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.position = 'fixed';
        menu.style.left = e.clientX + 'px';
        menu.style.top = e.clientY + 'px';
        menu.style.background = 'white';
        menu.style.border = '1px solid #ddd';
        menu.style.borderRadius = '4px';
        menu.style.padding = '5px 0';
        menu.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
        menu.style.zIndex = '1000';
        
        const options = [
            { text: 'Edit', action: () => this.editNode(node) },
            { text: 'Delete', action: () => this.deleteNode(node) },
            { text: 'Connect to...', action: () => this.startConnection(node) }
        ];
        
        options.forEach(option => {
            const item = document.createElement('div');
            item.textContent = option.text;
            item.style.padding = '8px 15px';
            item.style.cursor = 'pointer';
            item.addEventListener('click', () => {
                option.action();
                document.body.removeChild(menu);
            });
            item.addEventListener('mouseenter', () => {
                item.style.background = '#f8f9fa';
            });
            item.addEventListener('mouseleave', () => {
                item.style.background = 'white';
            });
            menu.appendChild(item);
        });
        
        document.body.appendChild(menu);
        
        // Remove menu when clicking elsewhere
        setTimeout(() => {
            document.addEventListener('click', function removeMenu() {
                if (document.body.contains(menu)) {
                    document.body.removeChild(menu);
                }
                document.removeEventListener('click', removeMenu);
            });
        }, 100);
    }
    
    deleteNode(node) {
        if (confirm('Delete this node?')) {
            this.nodes = this.nodes.filter(n => n.id !== node.id);
            this.connections = this.connections.filter(c => c.from !== node.id && c.to !== node.id);
            this.draw();
        }
    }
    
    startConnection(fromNode) {
        this.connectionMode = true;
        this.connectionFrom = fromNode;
        this.canvas.style.cursor = 'crosshair';
        
        const originalHandler = this.canvas.onclick;
        this.canvas.onclick = (e) => {
            const pos = this.getMousePos(e);
            const toNode = this.getNodeAt(pos.x, pos.y);
            
            if (toNode && toNode !== fromNode) {
                this.connections.push({
                    from: fromNode.id,
                    to: toNode.id
                });
                this.draw();
            }
            
            this.connectionMode = false;
            this.canvas.style.cursor = 'default';
            this.canvas.onclick = originalHandler;
        };
    }
    
    zoomIn() {
        this.zoom *= 1.2;
        this.draw();
    }
    
    zoomOut() {
        this.zoom /= 1.2;
        this.draw();
    }
    
    resetZoom() {
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.draw();
    }
    
    clear() {
        this.nodes = [];
        this.connections = [];
        this.selectedNode = null;
        this.draw();
    }
    
    exportToPNG() {
        const link = document.createElement('a');
        link.download = 'mindmap.png';
        link.href = this.canvas.toDataURL();
        link.click();
    }
    
    save() {
        const projectId = document.getElementById('projectSelect').value;
        if (!projectId) {
            alert('Please select a project first');
            return;
        }
        
        const data = {
            project_id: parseInt(projectId),
            nodes: this.nodes,
            connections: this.connections
        };
        
        fetch('/api/save_mindmap', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                alert('Mind map saved successfully!');
            } else {
                alert('Error saving mind map: ' + result.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error saving mind map');
        });
    }
    
    load(projectId) {
        fetch(`/api/load_mindmap/${projectId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.nodes = data.nodes || [];
                this.connections = data.connections || [];
                this.draw();
            }
        })
        .catch(error => {
            console.error('Error loading mind map:', error);
        });
    }
}

// Initialize mind map
let mindmap;

document.addEventListener('DOMContentLoaded', function() {
    mindmap = new AdvancedMindMap('mindmapCanvas');
    window.mindmap = mindmap; // Make globally accessible
    
    // Load mind map when project is selected
    document.getElementById('projectSelect').addEventListener('change', function() {
        const projectId = this.value;
        if (projectId) {
            mindmap.load(projectId);
        } else {
            mindmap.clear();
        }
    });
});

// Global functions
function createNode() {
    mindmap.createNodeAt(200, 200);
}

function clearCanvas() {
    if (confirm('Clear all nodes and connections?')) {
        mindmap.clear();
    }
}

function exportMindMap() {
    mindmap.exportToPNG();
}

function saveMindMap() {
    mindmap.save();
}

function zoomIn() {
    mindmap.zoomIn();
}

function zoomOut() {
    mindmap.zoomOut();
}

function resetZoom() {
    mindmap.resetZoom();
}
</script>
<script src="/static/js/mindmap.js"></script>
{% endblock %}